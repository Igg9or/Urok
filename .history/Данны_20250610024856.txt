Учитель:

Логин: teacher1

Пароль: teacher123

Ученик:

Логин: student1

Пароль: student123

$outputFile = ".\project_code.txt"

# Исключаемые директории
$excludedDirs = @(
    "__pycache__", ".git", ".idea", "node_modules", 
    "venv", "env", "dist", "build", "*.egg-info",
    "*.vs", "*.vscode", "*.history"
)

# Исключаемые файлы
$excludedFiles = @(
    "*.pyc", "*.pyo", "*.pyd", "*.db", 
    "*.log", "*.tmp", "*.bak", "*.swp", "*.swo", "*.min.*"
)

# Создаем выходной файл в UTF-8 с BOM (для корректного отображения русских символов)
[System.IO.File]::WriteAllText($outputFile, "", [System.Text.Encoding]::UTF8)

Get-ChildItem -Path . -Recurse -File | Where-Object {
    ($_.Extension -in '.py', '.js', '.html', '.htm') -and
    ($excludedFiles -notcontains $_.Name)
} | ForEach-Object {
    $skip = $false
    foreach ($dir in $excludedDirs) {
        if ($_.FullName -like "*\$dir\*") { $skip = $true; break }
    }
    if (-not $skip) { $_ }
} | ForEach-Object {
    $relativePath = $_.FullName.Substring((Get-Location).Path.Length + 1)
    $separator = "=" * 80
    $header = "`n$separator`nФАЙЛ: $relativePath`n$separator`n"
    
    # Добавляем заголовок
    [System.IO.File]::AppendAllText($outputFile, $header, [System.Text.Encoding]::UTF8)
    
    # Читаем содержимое файла с автоматическим определением кодировки
    $content = [System.IO.File]::ReadAllText($_.FullName)
    [System.IO.File]::AppendAllText($outputFile, $content, [System.Text.Encoding]::UTF8)
}

Write-Host "Готово! Все файлы сохранены в:"
Write-Host (Resolve-Path $outputFile).Path -ForegroundColor Green


1. Генерируй шаблоны строго в школьной логике:

Все параметры (особенно float) — только “красивые”, “школьные” значения.

Для float указывай "constraints": [{"type": "multiple_of", ...}], чтобы генерировались значения по шагу (например, 0.1, 0.5, 1).

Для int — значения в адекватных пределах и целые.

Если нужны конкретные варианты — используй "choice".

2. Не должно быть отрицательных результатов (если не требуется по смыслу):

Добавляй в "conditions" все необходимые условия, чтобы итоговое выражение всегда было положительным (или нулём, если требуется).

3. Для выражений с делением и разностями:

Всегда добавляй отдельное условие в "conditions", чтобы знаменатель/разность не обращались в ноль (например, ((B1/B2)-(C1/C2)) != 0).

Если нужно — дополнительно проверяй числитель/знаменатель на знак, чтобы не получить отрицательный результат.

4. Форматы ответов:

Все ответы для автопроверки должны быть числами, а не строками с символами (% и т.д.).

В answer_template проценты не указывай, только числа!

Вопрос формулируй так, чтобы ученик явно понимал, в каком виде писать ответ (например, “Ответ введите числом, без знака %”).

Если ответ состоит из списка чисел — все значения разделяй через ;, без лишних символов.

Если задание предполагает дроби или смешанные числа — ученик может ввести и обыкновенную дробь, и десятичную (парсер принимает оба формата).

5. Если требуется несколько ответов — строго контролируй количество и формат:

Если ученик ввёл не все ответы — это просто "неверно" (is_correct=False), а не техническая ошибка.

Если в ответе есть недопустимые символы — также возвращай просто "неверно".

6. Все условия и ограничения всегда явно указывай в шаблоне, чтобы при генерации не было случайных “плохих” значений.

7. При необходимости добавляй поясняющие инструкции для ученика в условие (например, курсивом через <i>...</i>).

8. В случае сложных формул и операций всегда учитывай при генерации “красоту” и “простоту” школьного примера.

9. Если в вопросе используются дроби, корни, степени или любые математические выражения —
всегда оформляй их в условии с помощью MathJax (через \\( ... \\) или \\[ ... \\]).
Пусть дроби и формулы выглядят красиво и понятно для ученика.
